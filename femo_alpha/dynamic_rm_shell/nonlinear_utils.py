from __future__ import annotations

# from numpy import float64
import numpy as np

import contextlib
import functools
import os
import typing

import ufl
from mpi4py import MPI
from dolfinx import cpp as _cpp
from dolfinx import la

from dolfinx.cpp.nls.petsc import NewtonSolver as _cpp_NewtonSolver

from dolfinx.cpp.fem import pack_coefficients as _pack_coefficients
from dolfinx.cpp.fem import pack_constants as _pack_constants
from dolfinx.fem import assemble
from dolfinx.fem.bcs import DirichletBCMetaClass
from dolfinx.fem.bcs import bcs_by_block as _bcs_by_block
from dolfinx.fem.forms import FormMetaClass
from dolfinx.fem.forms import extract_function_spaces as _extract_spaces
from dolfinx.fem.forms import form as _create_form
from dolfinx.fem.forms import form_types
from dolfinx.fem.petsc import _assemble_matrix_mat
from dolfinx.fem.petsc import (assemble_vector, assemble_matrix, create_vector, create_matrix, set_bc, apply_lifting)
# from dolfinx.nls.petsc import NewtonSolver
from dolfinx.fem.function import Function as _Function

import petsc4py
import petsc4py.lib
from petsc4py import PETSc


class NonlinearProblem_mod:
    """Nonlinear problem class for solving the non-linear problem
    :math:`F(u, v) = 0 \\ \\forall v \\in V` using PETSc as the linear algebra
    backend. This class was copied from the `NonlinearProblem` class that is built-in in DOLFINx

    """

    def __init__(self, F: ufl.form.Form, u: _Function, bcs: typing.List[DirichletBCMetaClass] = [],
                 J: ufl.form.Form = None, form_compiler_options={}, jit_options={}):
        """Initialize solver for solving a non-linear problem using Newton's method, :math:`dF/du(u) du = -F(u)`.

        Args:
            F: The PDE residual F(u, v)
            u: The unknown
            bcs: List of Dirichlet boundary conditions
            J: UFL representation of the Jacobian (Optional)
            form_compiler_options: Options used in FFCx
                compilation of this form. Run ``ffcx --help`` at the
                commandline to see all available options.
            jit_options: Options used in CFFI JIT compilation of C
                code generated by FFCx. See ``python/dolfinx/jit.py``
                for all available options. Takes priority over all
                other option values.

        Example::

            problem = LinearProblem(F, u, [bc0, bc1])

        """
        # TODO: Figure out why form_compiler_options and jit_options below are unexpected keywords. 
        #       According to the DOLFINx 0.6.0 documentation this should be correct
        self._L = _create_form(F)#, form_compiler_options=form_compiler_options,
                               #jit_options=jit_options)

        # Create the Jacobian matrix, dF/du
        if J is None:
            V = u.function_space
            du = ufl.TrialFunction(V)
            J = ufl.derivative(F, u, du)

        self._a = _create_form(J)#, form_compiler_options=form_compiler_options,
                               #jit_options=jit_options)
        self.bcs = bcs

    @property
    def L(self) -> FormMetaClass:
        """Compiled linear form (the residual form)"""
        return self._L

    @property
    def a(self) -> FormMetaClass:
        """Compiled bilinear form (the Jacobian form)"""
        return self._a

    def form(self, x: PETSc.Vec):
        """This function is called before the residual or Jacobian is
        computed. This is usually used to update ghost values.

        Args:
           x: The vector containing the latest solution

        """
        x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)

    def F(self, x: PETSc.Vec, b: PETSc.Vec):
        """Assemble the residual F into the vector b.

        Args:
            x: The vector containing the latest solution
            b: Vector to assemble the residual into

        """
        # Reset the residual vector
        with b.localForm() as b_local:
            b_local.set(0.0)
        assemble_vector(b, self._L)

        # Apply boundary condition
        apply_lifting(b, [self._a], bcs=[self.bcs], x0=[x], scale=-1.0)
        b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        set_bc(b, self.bcs, x, -1.0)
        # print("Vector assembly")

    def J(self, x: PETSc.Vec, A: PETSc.Mat):
        """Assemble the Jacobian matrix.

        Args:
            x: The vector containing the latest solution

        """
        A.zeroEntries()
        _assemble_matrix_mat(A, self._a, self.bcs)
        A.assemble()
        # print("Jacobian assembly")

# class NonlinearPDEProblem:
#     """Nonlinear problem class for a PDE problem."""

#     def __init__(self, F, u, bc):
#         V = u.function_space
#         du = TrialFunction(V)
#         self.L = form(F)
#         self.a = form(derivative(F, u, du))
#         self.bc = bc

#     def form(self, x):
#         x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)

#     def F(self, x, b):
#         """Assemble residual vector."""
#         with b.localForm() as b_local:
#             b_local.set(0.0)
#         assemble_vector(b, self.L)
#         apply_lifting(b, [self.a], bcs=[[self.bc]], x0=[x], scale=-1.0)
#         b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
#         set_bc(b, [self.bc], x, -1.0)

#     def J(self, x, A):
#         """Assemble Jacobian matrix."""
#         A.zeroEntries()
#         assemble_matrix(A, self.a, bcs=[self.bc])
#         A.assemble()

#     def matrix(self):
#         return create_matrix(self.a)

#     def vector(self):
#         return create_vector(self.L)

class NewtonSolver(_cpp_NewtonSolver):
    """
    This class was copied from dolfinx.nls.petsc.NewtonSolver, for reference and for future modifications
    """
    def __init__(self, comm: MPI.Intracomm, problem: NonlinearProblem):
        """A Newton solver for non-linear problems."""
        super().__init__(comm)

        # Create matrix and vector to be used for assembly
        # of the non-linear problem
        self._A = create_matrix(problem.a)
        self.setJ(problem.J, self._A)
        self._b = create_vector(problem.L)
        self.setF(problem.F, self._b)
        self.set_form(problem.form)

    def solve(self, u: fem.Function):
        """Solve non-linear problem into function u. Returns the number
        of iterations and if the solver converged."""
        n, converged = super().solve(u.vector)
        u.x.scatter_forward()
        return n, converged


    @property
    def A(self) -> PETSc.Mat:
        """Jacobian matrix"""
        return self._A

    @property
    def b(self) -> PETSc.Vec:
        """Residual vector"""
        return self._b

    def setP(self, P: types.FunctionType, Pmat: PETSc.Mat):
        """
        Set the function for computing the preconditioner matrix

        Args:
            P: Function to compute the preconditioner matrix
            Pmat: Matrix to assemble the preconditioner into
        """
        super().setP(P, Pmat)

def solveNonlinear_mod(F, w, bcs, abs_tol=1e-50, max_it=3, log=False):

    """
    Wrap up the nonlinear solver for the problem F(w)=0 and
    returns the solution
    """

    problem = NonlinearProblem_mod(F, w, bcs)

    # Set the initial guess of the solution
    with w.vector.localForm() as w_local:
        w_local.set(0.1)
    solver = NewtonSolver(MPI.COMM_WORLD, problem)
    if log is True:
        dolfinx.log.set_log_level(dolfinx.log.LogLevel.INFO)

    # Set the Newton solver options
    solver.atol = abs_tol
    solver.max_it = max_it
    solver.error_on_nonconvergence = False
    opts = PETSc.Options()
    opts["nls_solve_pc_factor_mat_solver_type"] = "mumps"
    solver.solve(w)